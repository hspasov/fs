H3: Block Device Storage Manager

Проектирайте структурата на сравнително проста файлова система
и напишете програма, която създава такава структура в указан файл
и реализира някои операции върху файловата система (ограничена
работа с директории и файлове).

Структурата на файловата система трябва да е базирана на inodes и data
blocks и да пази метаинформация за файловата система (вкл. специални
стойности, които я идентифицират) в superblock, подобно на някои от
широко използваните системи. Допустимо е да има само един екземпляр на
superblock-а. 

В приложената документация опишете решенията, които сте взели при
проектирането, причините за тях, допусканията, които сте направили за
естеството на данните и начина на използването им, всички структури от
данни, всички алгоритми, използвани за определяне на разположението им в
рамките на файловата система, както и всички алгоритми за избиране на
подходящи стойности, напр. максимален брой inodes и data blocks, както и
всякакви други описания, които сметнете за необходимо.

Конкретната структура на отделните елементи е по Ваша преценка, но
трябва да отговаря на следните условия:

- файловата система съдържа два вида обекти: файлове и директории
  (ако решите да изпълните и бонус-задачата Б4, има и трети тип
  обект - символна връзка)

- всеки обект има поне изредените по-долу атрибути

- съществува главна (root) директория и всеки съществуващ обект
  е достижим през определен път от директории, започващ от нея

- главната директория се означава с името "+"

- "пълен път към обект" ще наричаме низ, започващ с "+/" и
  съдържащ компоненти, разделени със символа "/". Тези компоненти
  са имената на всички директории, водещи от главната директория
  до обекта, следвани от самото име на обекта в директорията,
  която го съдържа (тя може да е главната)

- името на всеки обект се състои от един или повече от следните
  символи: главни и малки букви от латиницата, цифри от 0 до 9,
  символите "-", "_" и "."

- символът "+" не може да участва в името на никой обект - той е
  запазен за името на главната директория

- символът "/" не може да участва в името на никой обект - той е
  запазен за разделител между компонентите от пълния път към обекта

- няма ограничение за дължината на името на всеки обект, както
  и ограничение за общата дължината на пълния път към някой файл
  или директория

- имената "." и ".." са валидни, но нямат специално значение

- в дадена директория не може да има два или повече обекта с едно
  и също име

Така имаме следните примери:

- "+/foo.txt" е пълен път към обект (може да бъде файл или директория) с
  име "foo.txt", който се намира непосредствено в главната директория

- "+/foo/bar" е пълен път към обект (може да бъде файл или директория) с
  име "bar", който се намира в директория с име "foo", която на свой ред
  се намира в главната директориянта

- "+/foo/bar.dat/baz.tar.gz/quux" е пълен път към обект (може да бъде
  файл или директория) с име "quux", който се намира в директория с име
  "baz.tar.gz", която се намира в директория с име "bar.dat", която се
  намира в директория с име "foo", която се намира в главната директория

Както беше споменато по-горе, всеки обект (файл или директория) има поне
следните атрибути (метаданни), които трябва да са записани в полета с
поне указания размер:

- размер на обекта (4 байта)

- owner ID (2 байта)

- group ID (2 байта)

- access permissions (2 байта) със същата семантика за read/write/execute
  и owner/group/other като в POSIX (Unix-like) файлова система

- modification time (4 байта): време на последната промяна по обекта:
  създаване, промяна (за директория: създаване или изтриване на файл
  в нея; за файл: промяна на съдържанието му)

- запазени за бъдеща употреба (2 байта) (виж бонус Б3)

Структурите, в които ще се пази тази информация, както и подредбата и
отместването им, определете като част от дизайна на файловата система.
Отместването на всички важни структури от данни (superblock, inode,
начало на описание на директория, начало на съдържание на файл или
еквивалентите им във Вашата файлова система) спрямо началото на
файловата система трябва да бъде кратно на 512 (стандартен размер на
сектор за повечето дискове и подобни устройства).

Напишете програма fs, която да обработва файл,
който съдържа проектираната от Вас файлова система.
Името на обработвания файл е в променлива FS_FILE в обкръжението.
Програмата обработва файла с помощта на системните извиквания open(2),
close(2), read(2), write(2) и lseek(2). Всички операции за четене, писане
и промяна на текущата позиция (seek) във файла трябва да се извършват
на блокове с размер, кратен на 512 байта.

Размерът на указания файл ще бъде между 16 MiB и 1024 MiB и ще бъде число,
кратно на 512 (цяло число брой сектори - между 32768 и 2097152).
Програмата не трябва да променя размера на файла - ако в някой момент се
окаже, че мястото в него не стига, за да бъде създаден нов обект, тя
трябва да прекрати работата си с подходящо съобщение за грешка.

За тестове по време на разработката на програмата можете да създадете
подобен файл с помощта на някоя от следните команди или подобна:

    truncate -s 32M file.bin
    dd if=/dev/zero of=file.bin bs=1024k count=64

Програмата fs се извиква с поне един аргумент, указващ командата,
която да бъде изпълнена; отделните команди имат 0 или повече аргументи.
При успешно изпълнение на зададената команда програмата извежда
поисканите данни, ако има такива, и завършва изпълнението си с код
за грешка (exit code) 0. При възникване на грешка или откриване на
некоректни данни във файла програмата извежда подходящо съобщение за
грешка и прекратява изпълнението си с код за грешка, различен от 0.
Тези кодове за грешка трябва да бъдат описани в приложената документация.
Ако зададената команда не изисква промяна на данните върху виртуалната
файлова система, намираща се в указания файл, то програмата не трябва
да променя съдържанието на файла по никакъв начин и не трябва да се
опитва да изпълнява операции (системни извиквания), които изискват права
за промяна на съдържанието му.

Програмата fs трябва да поддържа поне тези команди:

0. `mkfs` (без аргументи): създава в указания файл първоначална
   структура на празна файлова система, състояща се само от главна
   директория без нито един обект. Това трябва да се случи независимо
   от това какви данни може да е имало преди това във файла.
   В момента на създаване на първоначалната структура на файловата
   система програмата fs трябва да определи подходящ максимален брой
   inodes и data blocks според размера на указания файл.

1. `fsck` (без аргументи): проверява за коректност файловата система,
   съдържаща се в указания файл. Проблемите, за които се проверява,
   са по Ваша преценка и следва да бъдат описани в документацията;
   програмата не се опитва да ги поправя. Ако програмата открие
   един или повече проблеми, тя извежда подходящо съобщение за грешка и
   прекратява работата си; това може да се случи още след първия открит
   проблем.

2. `debug` (без аргументи): извежда подробна информация по Ваш избор за
   структурата на файловата система, открита в указания файл, обектите
   в нея и метаданните им и т.н.

3. `lsobj +/path/to/object`: извежда информация за метаданните на
   указания обект във файловата система на един ред във формат, донякъде
   подобен на този на командата ls(1):

   access_mode ownerName groupName size mtime name

   Полето access_mode трябва да се състои от 10 символа: първият е "-"
   за файл и "d" за директория, а останалите са три групи от три
   символа, "r", "w", "x" или "-", отговарящи на правата за четене,
   писание или изпълнение от собственика, групата или всички останали.

   Полетата ownerName и groupName съдържат имената съответно на
   потребителския акаунт и групата, отговарящи на числовите стойности на
   полетата ownerID и groupID от метаданните на обекта. Може да
   използвате функциите getpwuid(3) и getgrgid(3).

   Полето mtime е в ISO-8601 формат "YYYY-MM-DDTHH:MM:SS".

   Ако решите да изпълните бонус-задачата Б4, за обекти, които
   представляват символни връзки, първият символ трябва да бъде "l".
   Всички останали полета на реда са по Ваша преценка и трябва да бъдат
   описани в документацията.

4. `lsdir +/path/to/directory`: извежда информация за метаданните на
   всички обекти в указаната директория, като за всеки обект се извежда
   по един ред в същия формат като изхода на `lsobj`.

5. `stat +/path/to/object`: извежда всички метаданни, които смятате за
   разумно, за указания обект (описани в документацията).
   Форматът на извежданата информация е изцяло по Ваша преценка.

6. `mkdir +/path/to/directory`: създава нова директория, която да е
   поддиректория на вече съществуваща (може и на главната). При
   създаването дайте на полетата owner ID и group ID на новия обект
   стойност 0, а на полето за права за достъп - стойност 0755.

7. `rmdir +/path/to/directory`: изтрива директория, която трябва да
   съществува, да не съдържа нито един обект и да не е главната.

8. `cpfile path/to/host/file +/path/to/file`: създава или презаписва
   съдържанието на файл в съществуваща директория, като прочита новото му
   съдържание от указания като първи аргумент файл върху
   външната файлова система. С други думи, копира файл от външната
   ("истинската") файлова система върху файл във виртуалната.
   След изпълнението на командата атрибутите owner ID, group ID и access
   permissions на виртуалния файл трябва да имат същите стойности като
   тези на файла-източник. Ако се окаже, че стойностите за owner ID и
   group ID на външния файл-източник са по-големи от 65535, можете да
   вземете само младшите два байта.

   `cpfile +/path/to/file path/to/host/file`: прочита съдържанието
   на указания съществуващ файл във виртуалната файлова система и
   създава (или презаписва) указания като втори аргумент файл върху
   външната файлова система с това съдържание. С други думи, копира файл
   от виртуалната файлова система върху външната. Ако външният файл не
   съществува, създайте го с owner и group, отговарящи на акаунта, от
   който се изпълнява командата fs (т.е. по подразбиране, без да ги
   взимате от виртуалната файлова система) и access mode u=rw,g=r,o=r.

9. `rmfile +/path/to/file`: изтрива съществуващия указан файл върху
   виртуалната файлова система. Ако сте изпълнили бонус задача Б3,
	трябва да вземете предвид броя на имената, сочещи към файла.

Важно е да се отбележи, че всички команди се държат така, като че ли са
изпълнени от потребител с пълни права за достъп върху всички обекти
във виртуалната файлова система. Всички метаданни, които биха се
отнасяли до контрол на достъпа (owner ID, group ID, access permissions
и т.н.), са само за справка ("for information purposes only"): програмата
fs не използва стандартния модел за сигурност на POSIX системи, а работи
с пълни права за достъп върху виртаулната файлова система.

Пример: като резултат от следната последователност от команди в текущата
директория трябва да има файл с име "passwd.txt", чието съдържание е
същото като на файла "/etc/passwd":

    export FS_FILE="$(pwd)/virtfs.bin"
    fs mkfs
    fs mkdir +/etc
    fs cpfile /etc/hosts +/etc/data.dat
    fs cpfile /etc/passwd +/etc/data.dat
    fs cpfile +/etc/data.dat passwd.txt
    fs rmfile +/etc/data.dat
    fs rmdir +/etc





Допълнителна (бонус) функционалност: добавете към програмата
fs възможността да изпълнява някои от следните допълнителни команди:


Б1. `chmod access_mode +/path/to/object`: променя правата за достъп в
    метаданните на съответния обект според зададения низ access_mode.
    Форматът на access_mode е по Ваш избор: осмично представяне, u/g/o +-/=
    r/w/x подобно на chmod(1) или нещо друго; във всеки случай той трябва
    да бъде описан в документацията.


Б2. `chown ownerName:groupName +/path/to/object`: променя стойностите на
    owner ID и group ID в метаданните на съответния обект. "ownerName" и
    "groupName" са съответно потребителско име и име на група, чиито
    числени стойности може да получите с помощта на функциите getpwnam(3)
    и getgrnam(3). Ако се окаже, че стойностите са по-големи от 65535,
    може да вземете младшите два байта.


Б3. `lnhard +/target/file +/new/filename`:
    - +/target/file е пълен път към съществуващ файл (не директория)
    - +/new е съществуваща директория
    - в директорията +/new не съществува обект с име filename
    
    Командата създава ново име (+/new/filename) на съществуващия файл
    +/target/file, което да сочи към същия inode.

Пример: като резултат от следната последователност от команди в текущата
директория трябва да има файл с име "passwd.txt", чието съдържание е
същото като на файла "/etc/passwd":

    export FS_FILE="$(pwd)/virtfs.bin"
    fs mkfs
    fs mkdir +/etc
    fs mkdir +/home
    fs mkdir +/home/acct
    fs cpfile /etc/hosts +/etc/data.dat
    fs lnhard +/etc/data.dat +/etc/hosts
    fs lnhard +/etc/hosts +/home/acct/data.dat
    fs cpfile /etc/passwd +/etc/data.dat
    fs cpfile +/home/acct/data.dat passwd.txt


Б4. Here be dragons!

    `lnsoft +/target/path +/new/newname`:
    - +/new е съществуваща директория
    - в директорията +/new не съществува обект с име filename

    Командата `lnsoft` създава нов обект +/new/newname от тип "символна
    връзка" ("l"), чието "съдържание" е пълният път +/target/path.

    Поведението на Вашата програма при работа с имплементирани символни
    връзки е изцяло по Ваше усмотрение, но следва да бъде описано
    подробно в документацията.

    Забележка: Процесът на resolve на пътища, в които участват символни
    връзки, е нетривиален.
